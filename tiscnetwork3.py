# -*- coding: utf-8 -*-
"""tiscnetwork3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10J0tk9OLY5_lc6bn07O9X_ykVslIjITE
"""

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Load your dataset
# Make sure to adjust the read_csv path to the actual CSV file with market data
# Example: your_data.csv should contain columns 'Open', 'Low', 'High'
df = pd.read_csv('/content/TISC Historical Data (3).csv')
# Inspect the first few rows
print(df.head())

# Prepare features and target variable
print(df.info())

import seaborn as sns
import matplotlib.pyplot as plt

n=df.describe()
n

plt.figure(figsize=(10,5))
plt.subplot(1,2,1)
sns.histplot(df['Open'],kde=True)
plt.subplot(1,2,2)
sns.histplot(df['High'],kde=True)
plt.tight_layout()
plt.show()

df.corr(numeric_only=True)

sns.heatmap(df.corr(numeric_only=True),annot=True)

sns.violinplot(df)

sns.kdeplot(df['Open'])
sns.kdeplot(df['High'])
sns.kdeplot(df['Low'])

sns.jointplot(x='Open',y='High',data=df,kind='hist')





X = df[['Open', 'Low']].values
y = df['High'].values

from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense
import pickle
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scaling the data
X_scaler = MinMaxScaler()
y_scaler = MinMaxScaler()

X_train_scaled = X_scaler.fit_transform(X_train)
X_test_scaled = X_scaler.transform(X_test)
y_train_scaled = y_scaler.fit_transform(y_train.reshape(-1, 1)).flatten()

with open('x_scaler1.pkl', 'wb') as f:
    pickle.dump(X_scaler, f)

with open('y_scaler2.pkl', 'wb') as f:
    pickle.dump(y_scaler, f)

print("Scalers saved successfully.")

model = Sequential([
    Dense(700, activation='relu', input_dim=2),
    Dense(856, activation='relu'),
    Dense(600, activation='relu'),
    Dense(900, activation='relu'),
    Dense(700, activation='relu'),
    Dense(500, activation='relu'),
    Dense(300, activation='relu'),
    Dense(100, activation='relu'),
    Dense(64, activation='relu'),
    Dense(16, activation='relu'),
    Dense(8, activation='relu'),
    Dense(1)
])

# Compile the model
model.compile(optimizer='adam', loss='mean_absolute_error', metrics=['mae'])

# Train the model using training data
model.fit(X_train_scaled, y_train_scaled, epochs=4000, batch_size=700,verbose=1)

from sklearn.metrics import mean_squared_error,r2_score,mean_absolute_error
y_pred_scaled = model.predict(X_test_scaled)
y_pred = y_scaler.inverse_transform(y_pred_scaled)

# Evaluation metrics
print("mse:", mean_squared_error(y_test, y_pred))
print("accuracy r2:", r2_score(y_test, y_pred))
print("mae:", mean_absolute_error(y_test, y_pred))

def predict_high(open_price, low_price):
    input_data = np.array([[open_price, low_price]])
    input_scaled = X_scaler.transform(input_data)  # Scale input
    predicted_high_scaled = model.predict(input_scaled)  # Make prediction
    predicted_high = y_scaler.inverse_transform(predicted_high_scaled.reshape(-1, 1))  # Inverse scale
    return predicted_high[0][0]

try:
    open_price = float(input("Enter the Open price: "))
    low_price = float(input("Enter the Low price: "))
    predicted_high = predict_high(open_price, low_price)
    print(f'Predicted High price: {predicted_high}')
except ValueError:
    print("Please enter valid numerical values for Open and Low prices.")

for i in y_test:
  print(i,end=' ')

for i in y_pred:
  print(i,end=' ')



model.save('mytatasteelnew.keras')

from tensorflow import keras

# Load the saved model
loaded_model = keras.models.load_model('mytatasteel.keras')

# Now you can use the loaded_model with your predict_high function:
def predict_high(open_price, low_price):
    input_data = np.array([[open_price, low_price]])
    input_scaled = X_scaler.transform(input_data)
    predicted_high_scaled = loaded_model.predict(input_scaled)
    predicted_high = y_scaler.inverse_transform(predicted_high_scaled.reshape(-1, 1))
    return predicted_high[0][0]

# Get predictions
try:
    open_price = float(input("Enter the Open price: "))
    low_price = float(input("Enter the Low price: "))
    predicted_high = predict_high(open_price, low_price)
    print(f'Predicted High price: {predicted_high}')
except ValueError:
    print("Please enter valid numerical values for Open and Low prices.")

model.summary()

y_test[0]

y_pred[0]

